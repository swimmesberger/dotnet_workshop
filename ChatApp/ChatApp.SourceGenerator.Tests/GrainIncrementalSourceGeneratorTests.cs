using ChatApp.Application.Domain.ChatRooms;
using ChatApp.Common.Grains;
using ChatApp.SourceGenerator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace SourceGenerators2.Tests;

public class GrainIncrementalSourceGeneratorTests {
    private const string GrainClassText = @"
using System.Threading;
using System.Threading.Tasks;
using ChatApp.Common.Grains;
using ChatApp.Application.Domain.ChatRooms;

namespace TestNamespace;

public sealed class ChatRoomGrain : IGrain {
    public Task<ChatRoom> JoinChatRoomAsync(int chatRoomId, int userId,  CancellationToken cancellationToken = default) {
        return Task.FromResult(new ChatRoom());
    }

    public Task RefreshChatRoomAsync(int chatRoomId, CancellationToken cancellationToken = default) {
        return Task.CompletedTask;
    }
}";

    private const string ExpectedGeneratedClassText = @"// <auto-generated/>

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ChatApp.Common.Actors.Abstractions;
using ChatApp.Common.Grains;
using ChatApp.Application.Domain.ChatRooms;

namespace TestNamespace;

internal sealed class JoinChatRoomCommand : IRequest<ChatRoom, JoinChatRoomCommand.Reply> {
    public required int ChatRoomId { get; init; }
    public required int UserId { get; init; }

    public sealed class Reply : IReply<ChatRoom> {
        public required ChatRoom State { get; init; }
    }
}

internal sealed class RefreshChatRoomCommand : IRequest {
    public required int ChatRoomId { get; init; }
}

public sealed class ChatRoomClient {
    private readonly IActorRef _actor;

    public ChatRoomClient(IRequiredActor<ChatRoomActor> actor) {
        _actor = actor.ActorRef;
    }

    public async ValueTask<ChatRoom> JoinChatRoomAsync(int chatRoomId, int userId, CancellationToken cancellationToken = default) {
        return await _actor.Ask(new JoinChatRoomCommand() {
            ChatRoomId = chatRoomId,
            UserId = userId
        }, cancellationToken: cancellationToken);
    }

    public async ValueTask RefreshChatRoomAsync(int chatRoomId, CancellationToken cancellationToken = default) {
        await _actor.Ask(new RefreshChatRoomCommand() {
            ChatRoomId = chatRoomId
        }, cancellationToken: cancellationToken);
    }
}

public sealed class ChatRoomActor : IActor {
    private readonly ChatRoomGrain _grain;

    public ChatRoomActor(IActorContext context) {
        _grain = new ChatRoomGrain();
    }

    public async ValueTask OnLetter(Envelope letter) {
        try {
            switch (letter.Body) {
                case InitiateCommand:
                    await ((IGrain)_grain).OnActivate(letter.CancellationToken);
                    letter.Sender.Tell(SuccessReply.Instance);
                    break;
                case PassivateCommand:
                    await ((IGrain)_grain).OnDeactivate(letter.CancellationToken);
                    letter.Sender.Tell(SuccessReply.Instance);
                    break;
                case JoinChatRoomCommand joinChatRoom:
                    var joinChatRoomResult = await _grain.JoinChatRoomAsync(joinChatRoom.ChatRoomId, joinChatRoom.UserId, letter.CancellationToken);
                    letter.Sender.Tell(new JoinChatRoomCommand.Reply() {
                        State = joinChatRoomResult
                    });
                    break;
                case RefreshChatRoomCommand refreshChatRoom:
                    await _grain.RefreshChatRoomAsync(refreshChatRoom.ChatRoomId, letter.CancellationToken);
                    letter.Sender.Tell(SuccessReply.Instance);
                    break;
            }
        } catch (Exception ex) {
            letter.Sender.Tell(new FailureReply(ex));
        }
    }
}
";
    [Fact]
    public void GeneratActor() {
        // Create an instance of the source generator.
        var generator = new GrainIncrementalSourceGenerator();

        // Source generators should be tested using 'GeneratorDriver'.
        var driver = CSharpGeneratorDriver.Create(generator);

        // We need to create a compilation with the required source code.
        var compilation = CSharpCompilation.Create(nameof(GrainIncrementalSourceGenerator),
            [CSharpSyntaxTree.ParseText(GrainClassText)],
            [
                // To support 'System.Attribute' inheritance, add reference to 'System.Private.CoreLib'.
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Task).Assembly.Location),
                // Add reference to 'ChatApp.Common.Grains' assembly.
                MetadataReference.CreateFromFile(typeof(IGrain).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(ChatRoom).Assembly.Location)
            ]);

        // Run generators and retrieve all results.
        var runResult = driver.RunGenerators(compilation).GetRunResult();

        // All generated files can be found in 'RunResults.GeneratedTrees'.
        var generatedFileSyntax = runResult.GeneratedTrees.Single(t => t.FilePath.EndsWith("ChatRoomClient.g.cs"));

        // Complex generators should be tested using text comparison.
        var generatedClassText = generatedFileSyntax.GetText().ToString();
        Assert.Equal(ExpectedGeneratedClassText, generatedClassText, ignoreLineEndingDifferences: true);
    }
}
